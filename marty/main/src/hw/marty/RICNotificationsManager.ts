import { RICHWElem, RICMsgHandler } from "@robotical/ricjs";
import { MartyConnector } from "./MartyConnector";
import RICServoFaultDetector from "@robotical/ricjs/dist/RICServoFaultDetector";

export class RICNotificationsManager {
  private martyConnector: MartyConnector;
  constructor(martyConnector: MartyConnector) {
    this.martyConnector = martyConnector;
  }

  setNotificationsHandler(ricMsgHandler: RICMsgHandler) {
    ricMsgHandler.reportMsgCallbacksSet(
      "notifyCB",
      this.reportNofication.bind(this)
    );
  }

  msgBodyDecider(report: any, hwElems: RICHWElem[]) {
    switch (report.msgBody) {
      case "overCurrentDet":
        if (!report.hasOwnProperty("IDNo")) break;
        let motor = report.IDNo;
        const motorElem = hwElems.find(({ IDNo }) => IDNo === report.IDNo);

        if (motorElem !== undefined) {
          motor = motorElem.name;
        }

        // TODO: add warnings manager to display warnings to user
        // adding warning to the manager where the warning message to
        // be displayed is decided
        // const ocwm = OverCurrentWarningManager.getInstanceOrInstantiate();
        // const warning = new OverCurrentWarning(motor);
        // ocwm.addWarning(warning);
        break;

      case "freefallDet":
        // this.emit(INCREMENT_FREE_FALL_WARNINGS);
        break;

      // Button A pressed Case
      case "btnAPressed":
        
        break;
    }
  }

  // REPORT notifications are messages generated by RIC in response to certain events, including raw i2c events and motor safeties
  reportNofication(report: any): void {
    const ricSystem = this.martyConnector._ricConnector.getRICSystem();
    const hwElems = ricSystem.getCachedAllHWElems();

    console.log(`reportNotification Report callback ${JSON.stringify(report)}`);

    if (report.hasOwnProperty("msgType")) {
      if (report.msgType === "raw") {
        this.handleServoFaultRawMsg(report);
        return;
      }

      if (report.msgType === "warn" && report.hasOwnProperty("msgBody")) {
        if (report.msgBody === "servoFaultDet") {
          // if there is a servo fault, we want to get the servo fault data using the servo fault detector
          console.log("servo fault detected");
          this.martyConnector._ricConnector.ricServoFaultDetector.atomicReadOperation(); // this will trigger reportMsgCallback, and so the above code will be executed
        } else if (report.msgBody === "elemCommsFailDet") {
          this.handleElemCommsFailDet(report);
        } else if (report.msgBody === "busFailDet") {
          this.handleBusFailDet(report);
        }

        this.msgBodyDecider(report, hwElems);
      }
    }
  }

  handleServoFaultRawMsg(report: any) {
    // return;
    const detectedServoFaults =
      RICServoFaultDetector.interpretReportMsg(report);
    // const detectedServoFaults = {
    //   intermittentConnection: true,
    //   noConnection: false,
    //   faultyConnection: false,
    //   servoHornPositionError: false,
    // }; // DEBUGGING ONLY
    const humanReadableServoFaults = {
      intermittentConnection: "Intermittent Connection",
      noConnection: "No Connection",
      faultyConnection: "Faulty Connection",
      servoHornPositionError: "Servo Horn Position Error",
    };
    if (detectedServoFaults) {
      for (const servoFaultKey in detectedServoFaults) {
        if (
          detectedServoFaults[servoFaultKey as keyof typeof detectedServoFaults]
        ) {
          const enhancedDescription = `${
            report.elemName
          } Servo Fault Detected: ${
            humanReadableServoFaults[
              servoFaultKey as keyof typeof humanReadableServoFaults
            ]
          }`;
        }
      }
      console.log(`detected servo faults`, detectedServoFaults);
    }
  }

  handleElemCommsFailDet(report: any) {
    // return;
    // this is triggered if we get multiple occurrences of loss of comms with an addon
    // An IDNo will be reported, this can be cross referenced against the
    // hwstatus output to determine which element is giving the error, and hence which leg has a problem
    const warningKey = `elemCommsFailDet ${report.elemName || report.IDNo}`;
  }

  handleBusFailDet(report: any) {
    // return;
    // this is a bit of a catch all, which will trigger if we get multiple i2c bus failures.
    // We won't be able to figure out which element is causing the failure from this, but it tells us something is up
    const warningKey = `busFailDet ${report.elemName || report.IDNo}`;
  }
}
